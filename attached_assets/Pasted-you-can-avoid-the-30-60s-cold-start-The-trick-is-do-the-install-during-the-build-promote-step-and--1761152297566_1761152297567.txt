you can avoid the 30–60s cold start. The trick is: do the install during the build/promote step and ship a prebuilt, self-contained image, then keep the runtime command as a tiny “start only”.

Here’s a battle-tested setup that keeps cold starts snappy on Replit:

1) Bake deps at build (not at boot)

In your Deploy/Promote settings (or whatever runs during “Promote”), set the Build command to:

npm ci && npm run build && npm prune --omit=dev


Set the Run command to:

npm start


This way, the container image already includes node_modules and compiled output. Cold start won’t run npm install.

If you’re doing this via .replit, keep the runtime run as just npm start. Do the npm ci && npm run build in the promote/build phase, not in the runtime run line.

2) Make Next.js “standalone” (smaller runtime, faster cold start)

In apps/frontend/next.config.js:

const path = require('path');

/** @type {import('next').NextConfig} */
module.exports = {
  output: 'standalone',
  // monorepo: make file-tracing resolve outside the app folder
  experimental: {
    outputFileTracingRoot: path.join(__dirname, '../..'),
  },
};


Then, at runtime you can start the prebuilt server directly:

Option A (simple): keep start as next start -p $PORT (works fine).

Option B (leaner): run the traced server:

// apps/frontend/package.json
"scripts": {
  "build": "next build",
  "start": "node .next/standalone/server.js"
}


Make sure .next/static and public/ are alongside the server (Next’s standalone build expects them). In a monorepo, that’s already true because you’re not copying between images — you’re running in-place.

3) Ensure runtime deps are truly in dependencies

Frontend: next, react, react-dom → dependencies (not dev).

Backend: everything you import at runtime (@nestjs/*, reflect-metadata, rxjs, ORM client, etc.) → dependencies.

4) (Optional) Bundle the backend to reduce runtime node_modules

If you want to go even leaner (and sometimes shave more seconds):

After nest build, bundle with ncc:

// apps/backend/package.json
"scripts": {
  "build": "nest build && npx ncc build dist/main.js -o dist-bundle",
  "start:prod": "node dist-bundle/index.js"
}


This packages most deps into one file (avoid native add-ons like pg-native). Runtime no longer needs most of node_modules.

5) Keep only one listener on $PORT

Next.js should bind to $PORT.

NestJS should bind to an internal port (e.g., 4000), and the frontend calls http://127.0.0.1:4000.

TL;DR

Don’t run npm install at cold start. Do it in the Promote/Build step and prune dev deps there.

Use Next “standalone” output to minimize runtime footprint.

(Optionally) bundle the Nest backend with ncc for an even smaller runtime.

Runtime command becomes a tiny npm start, which makes cold starts fast.