Here’s the single, permanent controller prompt. Paste it into your Replit Agent chat (in your fork). It installs forever-on enforcement, adds missing tests, and runs fast suites + tiny E2E smoke across Settings, B2C, B2B, Trade. It also self-diagnoses and patches failures.

⸻

Permanent Controller — Test & Quality Enforcement (Settings + B2C + B2B + Trade)

Run non-interactive. Assume I’m offline. This policy is permanent: apply on every commit, branch, and publish.

Global execution rules
	•	Execute the tasks below in order; verify each step; retry up to 3 times on failure; if still failing, log and continue.
	•	Persist state between steps.
	•	Save logs/reports under /reports/ (timestamped).
	•	Add a background watcher that re-runs fast tests on file change and auto-stubs missing tests.
	•	Add pre-commit hook blocking: missing tests, type/lint errors, changed-lines coverage <80%, contract drift, render failures.
	•	Add a project task that runs nightly: full fast pack + tiny E2E smoke + flake report.
	•	Skip Playwright browsers locally (Replit), but keep cloud or container E2E config if creds available.

⸻

1) Foundations (once, then enforce)
	1.	Typing & schemas: enable TS strict; centralise Zod/Pydantic schemas; generate shared types in /packages/shared.
	2.	Contract tests: GraphQL schema snapshot + per-operation contract tests. Fail on breaking changes.
	3.	Secrets gate: boot-time test fails if required envs missing (Stripe PK/secret, FX source, email, Shippo).
	4.	ESLint rules: forbid currency string literals (USD, EUR, …) outside config; forbid direct DOM access in React components; forbid unguarded any.
	5.	Observability: /metrics (Prometheus) + /healthz. Add counters used later.

Reports: /reports/01_foundations.md

⸻

2) Services (backend) — unit/integration/contract

Implement tests + guards for each service. Default mocks are pessimistic (some 500/timeouts) unless a test opts into “happy”.
	•	Auth & RBAC: JWT/session expiry with time-travel; role matrix (buyer/seller/admin/support); unauthorized → 401/403; service methods refuse disallowed roles.
	•	Currency & FX: single source of truth; FX outage → cached rate; rounding rules; locale formatting snapshots.
	•	Payments (Stripe): intent/confirm/refund/dispute; idempotency keys; Connect account state propagation; webhook replay safe.
	•	Email: template snapshot (HTML/text), message_key idempotency, bounce/complaint suppression, link signing & 200 check.
	•	Wallet: add funds min/max; ledger invariants (debits=credits); spend guards for Shippo/Meta; balance contract (amount,currency).
	•	Shipping: matrix precedence vs free/flat/Shippo; region and range matching; Shippo rate timeout/500 → matrix fallback.
	•	Tax: Stripe Tax IDs; totals composition (subtotal/tax/shipping/discount); 0.5 rounding edges; mixed currencies handled.
	•	Catalog: product types (in-stock / pre-order / made-to-order), variant matrices (size, color, both), media MIME/size limits.
	•	Orders: state machine (new→paid→fulfilled→refunded); partial/full refunds; duplication and replay protection.
	•	Files/CDN: signed URL scope+expiry; upload MIME/size checksum; CDN cache headers.
	•	Queues/Events: publish, retry/backoff caps, DLQ; dedupe keys; event payload snapshots.
	•	Sockets: namespace auth; per-role broadcast scoping; reconnect/backoff; versioned payload tolerance.
	•	Analytics: KPI aggregations reconcile with ledger and orders; date-range filters.

Reports: /reports/02_services.md

⸻

3) Frontend integrity — component/route tests (no browser)
	•	Route/loader: shallow render each page + loader; when data is null/error, enforce skeleton/empty-state (no white screen).
	•	Error boundaries: throwing components render fallback.
	•	State transitions: modal open/close; after side effects (connect success/webhook) the view reflects new state.
	•	SSR/CSR: hydration safety (no window in SSR).
	•	Formatting: currency/locale snapshots pulled from service, not literals.

Reports: /reports/03_frontend.md

⸻

4) Settings module (Seller)
	•	Quick Setup / About & Contact: contract + component tests; footer populated or shows controlled fallback.
	•	Profile from Stripe: after Connect (mocked), profile fields sync; nulls handled.
	•	Shipping matrix: precedence and parsing; country/continent matching; days/cost ranges.
	•	Warehouse: address validation for Shippo integration.
	•	Saved cards: tokenization mock; list/create/delete; no PAN in logs.
	•	Tax: save & apply tax IDs; totals include/exclude logic.
	•	Terms/Policies: upload (PDF/DOC), sanitize, rendered on PDP.
	•	Categories: create/edit/reorder/delete; slug uniqueness; orphan checks.
	•	Team: invite/accept/decline; RBAC enforced.
	•	Payment: Stripe.js init must fail test when publishable key missing; Connect state visible; store currency set → propagation tests.
	•	Subscription: start trial, change plan, cancel at period end; UI reflects status after mocked webhooks.
	•	Domains: DNS/CNAME verify mock; baseURL switches when verified.

Reports: /reports/04_settings.md

⸻

5) B2C — fast tests
	•	PDP: variant selection, stock visibility; pre-order caps/dates; terms & policies render.
	•	Cart/Checkout logic: concurrent last-unit race; idempotent payment key; totals composition (discount/tax/shipping/rounding); shipping mode precedence (free/flat/matrix/Shippo).
	•	Emails: order confirmation queued once; links valid; suppression respected.
	•	Orders: invoice + packing list (PDF smoke) immutable numbering; returns/refunds update ledger.

Reports: /reports/05_b2c.md

⸻

6) B2B — fast tests (Wholesale)
	•	Onboarding & RBAC: invite→accept/decline; price-list visibility by segment; catalog isolation.
	•	Wholesale Create: MOQ enforced across variants; Deposit% in [0,100]; NET terms 15/30/60/90 with due date; readiness (days vs fixed) mutually exclusive; stock 0=MTO; variant totals; warehouse required; legal PDF validated.
	•	Pricing & FX: segment overrides; effective-date windows; FX outage fallback; currency formatting.
	•	Catalog/Preview: wholesale-enabled SKUs only; draft hidden; category filters/reorder persist.
	•	Checkout logic: deposit captured at checkout; balance scheduled; block when Connect missing with actionable error.
	•	Orders & docs: invoice (deposit+balance schedule) + packing list; partial/full payments reconcile ledger; cancellation/refund policies audited.
	•	Emails/webhooks: invite, order placed, deposit paid, invoice issued, balance due/reminder; idempotent; replay safe.
	•	Sockets: seller sees order/payment/invoice events; buyer only their own; reconnect/backoff.

Reports: /reports/06_b2b.md

⸻

7) Trade — fast tests (Quotations → Trade Orders)
	•	Quotation create:
	•	Auto-number if empty; custom number allowed; numbers unique/immutable.
	•	Currency from store (or selection if supported) — no literals.
	•	Incoterms required; serialize code + location; validation errors covered.
	•	Valid-until date; time-travel expired → un-actionable.
	•	Deposit slider 0–100% with rounding; deposit amount = % × subtotal (pre-tax or post-tax as spec); unit tests for formula.
	•	Line items add/remove; totals recompute; zero or negative guarded.
	•	Attachments: datasheet (PDF) and T&Cs (PDF/DOC) validated; stored with safe names; links rendered in PDF/email.
	•	Tax & shipping fields applied to entire quotation; totals snapshot.
	•	Quote lifecycle: draft → sent → accepted/rejected → converted to Trade Order; versioning on edits; audit trail entries appended once.
	•	Emails: quote sent/accepted/expired; secure accept link; idempotent.
	•	Trade Orders: becomes order with deposit capture and balance schedule (terms mirror quote); invoices generated; refunds/cancellations policies.
	•	Sockets: events quote.sent, quote.accepted, quote.expired, trade_order.created with RBAC scoping.
	•	Analytics: dashboard cards (total/pending/accepted/revenue) reconcile with quotes/orders.

Reports: /reports/07_trade.md

⸻

8) Tiny E2E smoke (fast; agent-free)
	•	B2C smoke: connect (mock) → create 1 in-stock product (1 variant) → buyer adds to cart → chooses one shipping mode → pays → success → email queued.
	•	B2B smoke: connect (mock) → create 1 wholesale product (MOQ 10, deposit 30%, NET30) → invite buyer → buyer orders ≥ MOQ → deposit captured → invoice generated.
	•	Trade smoke: create quote (deposit 50%, NET30, Incoterm EXW, 1 line) → send → accept → trade order created → deposit captured.

Setup: Playwright config skips locally (REPL_ID/NO_E2E). If BROWSERSTACK_* or LT_* secrets exist, add cloud config/scripts e2e:smoke:cloud and run there. Traces/screenshots on failure only.

Reports: /reports/08_e2e_smoke.md

⸻

9) Metrics & Health (assertions across all)

Emit and test increments for:
api_error_total{route,code}, graphql_latency_ms{op}, wallet_balance_error_total, stripe_connect_init_error_total, route_render_fail_total{route}, fx_fallback_total, b2b_moq_violation_total, b2b_deposit_capture_fail_total, b2b_balance_overdue_total, quote_expired_total, trade_order_created_total.
/healthz degrades when any dependency mock is set to fail.

Reports: /reports/09_metrics_health.md

⸻

10) Continuous-improve loop (always on)
	•	On any failing test or render sweep: classify {missing mock, selector drift, schema drift, async timing, seed/data, permission, socket}.
	•	Auto-patch minimal diff (test or code) and re-run the failing shard only.
	•	Quarantine flakies (retry=1), open flake note with logs; schedule nightly repair.
	•	Update contracts/fixtures when drift is legitimate; reject otherwise.
	•	Maintain /reports/continuous_improve.log.

⸻

11) Outputs & gating
	•	For each step, write a short report.
	•	Generate /reports/full-setup-summary.md at the end: files changed, tests added, coverage deltas, p95 deltas, contract drift, socket coverage, flaky list, health/metrics status, unresolved blockers with proposed patches.
	•	Keep enforcement enabled permanently: watcher + pre-commit + nightly job run without me instigating it again.

Execute now.