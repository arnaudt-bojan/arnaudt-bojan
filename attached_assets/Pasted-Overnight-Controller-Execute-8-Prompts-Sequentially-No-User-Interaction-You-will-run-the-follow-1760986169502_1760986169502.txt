Overnight Controller — Execute 8 Prompts Sequentially (No User Interaction)

You will run the following eight prompts in order (1→8). Treat each as a separate job.
Assume I will not respond. Do not wait for me.

For each step:
	•	Execute exactly as written (no compression/merging).
	•	Verify success criteria; on failure, retry up to 3 times.
	•	If still failing, log the error, continue to the next step, and include details in the final report.
	•	Persist all files/config/state between steps.

Global rules (apply to all steps):
	•	Prefer deterministic seeds; keep runs fast; mock externals; don’t use “agent-in-agent” flows.
	•	Generate concise progress logs after each step.
	•	Save all outputs/reports under /reports/ with timestamps.
	•	At the end, run a full validation pass and write /reports/full-setup-summary.md with: overall status, files changed, tests added, coverage deltas, p95 latency deltas, socket coverage, contract drift, flake list, /healthz and /metrics status, and any unresolved blockers with proposed patches.

⸻

Prompt 1 — Complete Test System Review & Coverage Expansion

Objective: Audit and expand tests across B2C, B2B, Trade (backend, frontend, socket).
Tasks:
	1.	Inventory existing unit/integration/component/contract/E2E/socket tests; output a matrix (file → tests present → gaps → priority).
	2.	Backfill missing tests using current mocks/fixtures/conventions:
	•	Backend: business logic, DB triggers, migrations, idempotency, queues/events, auth/rate-limits, externals (payments/email/shipping) mocked.
	•	Frontend: shallow render for all pages/components; prop/context null-guards; capture console errors; minimal snapshots.
	•	Socket.io: connect/disconnect, payload schema, broadcast scope, namespace/auth, retry/error; multi-client (buyer/seller/admin).
	3.	Ensure runner/CI discover and run new tests.
	4.	Output /reports/01-review-summary.md: tests added, files covered, remaining gaps.

⸻

Prompt 2 — Global Auto-Coverage & Enforcement (Watcher + CI gates)

Objective: Enforce “tests for every change.”
Implement:
	•	Auto-coverage rule: on any new/changed .ts/.tsx/.prisma/socket file, detect missing tests; auto-create stubs (unit/integration/component/socket/E2E as applicable).
	•	Backend: auth/schema/rate-limit checks; DB logic, migrations (apply/verify/rollback), idempotency, triggers, queues (publish/retry/DLQ); externals mocked.
	•	Frontend: shallow render; fail on missing exports/undefined props/blank renders; snapshot key states.
	•	Socket: auto-detect new events; generate tests; validate connect/disconnect, payloads, broadcast scope, auth/namespace, retry/error.
	•	Metrics/health: emit api_latency_ms, api_error_total, socket_emit_total; keep /healthz and /metrics green.
	•	Automation: watcher that generates stubs; pre-commit hook blocks missing tests or type/lint errors; CI fails PR if changed files lack tests.
	•	Output /reports/02-enforcement-setup.md and print PR summary template (changed files ↔ tests ↔ socket coverage ↔ p95 deltas).

⸻

Prompt 3 — Fast, Agent-Free E2E Baseline (Playwright)

Objective: Sub-10 min full E2E; sub-5 min local smoke.
Implement:
	•	playwright.config.ts: fullyParallel:true, retries:1, reuseExistingServer:true, storageState:'storageState.json', headless, trace:'on-first-retry', video:'off', screenshot:'only-on-failure', tight timeouts, Chromium project.
	•	scripts/create-storage-state.ts: one-time login to save storageState.json.
	•	Tag @smoke; support --shard; seed via API/fixtures (no UI setup).
	•	Route/HAR mocks for payments/email/3P.
	•	CI: smoke on PR, full nightly; cache browsers and node_modules.
	•	Output /reports/03-e2e-baseline.md with runtime and failures (trace links).

⸻

Prompt 4 — Full E2E Plan & Execution (B2C, B2B, Trade) + Continuous-Improve Loop

Objective: Build and run a comprehensive E2E suite across all planes and improve it during execution.
Flows:
	•	B2C: browse/search → PDP → add-to-cart → checkout → pay → confirm → email → refund/return.
	•	B2B: login → price lists/MOQ/NET terms → quote → approval → PO → invoice → shipment → credit/limit checks.
	•	Trade/Admin: seller onboarding → catalog import/edit → inventory updates → pricing rules → order management → analytics snapshots.
Negative cases: auth fail, invalid payment, OOS at checkout, price change mid-flow, webhook retry, permission denied.
Seeds: deterministic fixtures; per-test isolation. Mocks: only externals (payments/email/carriers); keep GraphQL live.
Targets: local full ≤10m, nightly ≤20m. Shard by plane/feature; reuse server/storageState; traces/screenshots on failure only.
Continuous-improve loop: run shard → on failure classify {missing mock, selector drift, schema drift, async, seed, permission, socket} → auto-patch minimal diff → re-run failing shard → if flaky, quarantine (retry=1) + log; update contracts/fixtures/tests as needed; continue until green or produce blocker list with proposed patches.
Output: /reports/04-e2e-full-run.md with per-plane pass/fail, root-cause histogram, p95 step timings, KPIs (totals/tax/inventory deltas), patches applied, quarantined tests.

⸻

Prompt 5 — Test-With-Every-Change Scaffolder + Hooks

Objective: Never merge code without matching tests + telemetry.
Implement:
	•	pnpm scaffold:test <path> generates stubs: unit, integration (DB txn/rollback), component, contract (GraphQL snapshot), socket (multi-client).
	•	Watcher: auto-add tests for new TS/TSX/Prisma/socket files; print TODOs.
	•	Pre-commit (husky + lint-staged): block commits if tests missing, GraphQL snapshot outdated, changed-line coverage <80%, or type/render checks fail.
	•	CI PR flow: fast pack (<60s) = unit + integration + contract + route-render sweep + socket fast + @smoke E2E; nightly = full + chaos + flake quarantine.
	•	Output /reports/05-scaffolder-hooks.md and PR summary template; enforce merge block on failure.

⸻

Prompt 6 — Repo-Wide Speed & Quality Upgrades

Objective: Raise quality, reliability, and velocity.
Implement:
	•	TS strict (strict:true, noUncheckedIndexedAccess:true).
	•	Centralise schemas; GraphQL/OpenAPI codegen; CI fails on drift.
	•	MSW + Storybook for UI speed/snapshots.
	•	Preview deploy per PR (shadow DB + seeded fixtures) and auto-comment URL.
	•	Flake control (retry once, nightly report); cache Playwright/Prisma; pin versions.
	•	Migration linter + db:revert; shadow DB in CI.
	•	Golden datasets (pricing/tax/inventory).
	•	Feature flags + kill-switch tests.
	•	SLO gates (p95 thresholds) + micro-load on cart/checkout.
	•	Observability: structured logs, trace IDs, /metrics & /healthz.
	•	Security: secret scan, dep audit, CSP, signed URL tests.
	•	Output /reports/06-speed-quality.md.

⸻

Prompt 7 — Monorepo Alignment & Architecture-3 Enforcement

Objective: Enforce Next.js+MUI (web), NestJS+GraphQL+Prisma+socket.io (api), with shared packages.
Structure: /apps/web, /apps/api, /packages/shared.
Tasks: GraphQL codegen (web hooks + api resolvers), GraphQL schema snapshot tests (CI break on drift), socket event registry (/packages/shared/socket/events.ts) + auto-generated tests, fast harness for Next components + Nest resolvers (Prisma txn rollback), Playwright @smoke with GraphQL mocks, Replit on Nix+pnpm (no Docker runtime), CI with Docker Compose parity.
Output: /reports/07-monorepo-arch3.md.

⸻

Prompt 8 — Feature-Delivery Checklist Gate

Objective: Enforce delivery discipline for every feature.
Checklist: E2E UX mapped + dependent flows; edge cases (stock/pre-order/back-order/payment fail); emails (idempotent + suppression, signed links); error/success + empty states; landing-page impact; design-system alignment; dark/light; responsive; tests present/passing; metrics & audits emitted; /healthz green; CI PR pipeline (unit → integration → render → contract → socket → @smoke E2E → SLO gate) all pass.
PR Output Table: changed files ↔ tests added/updated ↔ coverage % ↔ socket coverage ↔ p95 deltas ↔ checklist pass/fail.
Enforce: block merge on any failed item.
Output: /reports/08-feature-gate.md.

⸻

Final step (run automatically):
After Prompt 8 completes, run a full validation pass and write /reports/full-setup-summary.md (status, artifacts, unresolved blockers with proposed patches). Then stop.